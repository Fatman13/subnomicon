"use strict";(self.webpackChunkportal=self.webpackChunkportal||[]).push([[412],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>u});var a=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var c=a.createContext({}),l=function(e){var t=a.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=l(r),u=n,y=h["".concat(c,".").concat(u)]||h[u]||d[u]||o;return r?a.createElement(y,i(i({ref:t},p),{},{components:r})):a.createElement(y,i({ref:t},p))}));function u(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,i=new Array(o);i[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:n,i[1]=s;for(var l=2;l<o;l++)i[l]=r[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,r)}h.displayName="MDXCreateElement"},4408:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=r(7462),n=(r(7294),r(3905));const o={title:"Network Layers",sidebar_position:3,description:"DSN Layers",keywords:["Consensus","Network","Storage","DSN"]},i=void 0,s={unversionedId:"network/dsn/layers",id:"network/dsn/layers",title:"Network Layers",description:"DSN Layers",source:"@site/docs/network/dsn/layers.md",sourceDirName:"network/dsn",slug:"/network/dsn/layers",permalink:"/docs/network/dsn/layers",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Network Layers",sidebar_position:3,description:"DSN Layers",keywords:["Consensus","Network","Storage","DSN"]},sidebar:"tutorialSidebar",previous:{title:"Overview",permalink:"/docs/network/dsn/"},next:{title:"Decoupled Execution",permalink:"/docs/category/decoupled-execution"}},c={},l=[{value:"Pieces cache layer(L2)",id:"pieces-cache-layerl2",level:2},{value:"Archival Storage layer(L1)",id:"archival-storage-layerl1",level:2},{value:"Piece cache types by peer roles",id:"piece-cache-types-by-peer-roles",level:2}],p={toc:l};function d(e){let{components:t,...o}=e;return(0,n.kt)("wrapper",(0,a.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"The DSN consists of multiple distinctive layers. While all layers serve pieces of the history, they work together to ensure different aspects of data availability, durability and efficient retrievability."),(0,n.kt)("h2",{id:"pieces-cache-layerl2"},"Pieces cache layer(L2)"),(0,n.kt)("p",null,"Pieces cache layer serves to quickly get pieces for data reconstruction and farming. The main purpose of this layer is to reduce latency of piece retrieval. Retrieval of pieces from Archival Storage requires farmers to read and decode their plotted sectors, which is a computationally intensive operation that currently takes ~1 second. In contrast, retrieval of pieces from L2 is almost instant as they are kept in memory. For this reason, the default way to acquire pieces is getting them from L2."),(0,n.kt)("p",null,"The piece cache layer stores pieces in the DHT by the proximity of piece index hash to peer ID. While any peer can store pieces in the L2 cache, at the moment we mostly rely on farmers as the most suitable candidates for pieces L2. Farmers dedicate a tiny part of their total pledged storage space to store L2 pieces. Several farmers closest to each other as peers by peer ID may store the same piece, determined by the overall storage network replication factor."),(0,n.kt)("p",null,"Piece cache layer is populated as follows:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"New pieces are produced by nodes during the Archiving process. "),(0,n.kt)("li",{parentName:"ul"},"Farmers receive the segment index from the latest block header from the connected node. "),(0,n.kt)("li",{parentName:"ul"},"Farmers derive the piece index hashes from the segment index and compare their peer ID with those hashes to determine whether they should download any pieces from this segment to their L2. "),(0,n.kt)("li",{parentName:"ul"},"Farmers pull relevant pieces to their local L2 cache.")),(0,n.kt)("h2",{id:"archival-storage-layerl1"},"Archival Storage layer(L1)"),(0,n.kt)("p",null,"The Archival Storage layer is the fundamental layer responsible for permanent storage and durability of all chain data. It consists of all storage pledged by farmers that is used to store encoded pieces of chain history."),(0,n.kt)("p",null,"This layer stores the blockchain history data in the encoded form as an integral part of the ",(0,n.kt)("a",{parentName:"p",href:"/docs/category/dilithium-consensus"},"Dilithium consensus"),". It stores the pieces encoded into plot sectors in SSD files. "),(0,n.kt)("p",null,"The Archival Storage layer serves as the \u201ccold storage\u201d and guarantees the history pieces are available when they couldn't be retrieved from L2. Retrieval from Archival storage, however, consumes a moderate amount of time and resources and is expected to be used only in the rare event of L2 cache miss.\nIn most cases, the L1 layers of farmers are populated with pieces received from L2."),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"DSNLayers",src:r(9237).Z,width:"2593",height:"975"})),(0,n.kt)("h2",{id:"piece-cache-types-by-peer-roles"},"Piece cache types by peer roles"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Node cache")," contains newly archived pieces from the latest segments. It is limited to a few recent segments and older pieces are gradually replaced with new data."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Farmer cache")," contains pieces in L2 cache that is automatically populated upon receiving the new archived segment announcements. Pieces are cached according to the proximity to the farmer's peer ID.")))}d.isMDXComponent=!0},9237:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/DSN_Layers-96bb3f21013892e4016db3170e7ffc67.png"}}]);