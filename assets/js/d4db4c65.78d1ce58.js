"use strict";(self.webpackChunkportal=self.webpackChunkportal||[]).push([[952],{3905:(e,t,r)=>{r.d(t,{Zo:()=>h,kt:()=>u});var a=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function n(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,a,o=function(e,t){if(null==e)return{};var r,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):n(n({},t),e)),r},h=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var r=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),d=c(r),u=o,m=d["".concat(l,".").concat(u)]||d[u]||p[u]||i;return r?a.createElement(m,n(n({ref:t},h),{},{components:r})):a.createElement(m,n({ref:t},h))}));function u(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=r.length,n=new Array(i);n[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,n[1]=s;for(var c=2;c<i;c++)n[c]=r[c];return a.createElement.apply(null,n)}return a.createElement.apply(null,r)}d.displayName="MDXCreateElement"},9414:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>n,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=r(7462),o=(r(7294),r(3905));const i={title:"Distributed Storage Network",sidebar_position:2,description:"Distributed Storage Network",keywords:["Consensus","Network","Storage","DSN"]},n=void 0,s={unversionedId:"network/dsn",id:"network/dsn",title:"Distributed Storage Network",description:"Distributed Storage Network",source:"@site/docs/network/dsn.md",sourceDirName:"network",slug:"/network/dsn",permalink:"/docs/network/dsn",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Distributed Storage Network",sidebar_position:2,description:"Distributed Storage Network",keywords:["Consensus","Network","Storage","DSN"]},sidebar:"tutorialSidebar",previous:{title:"Node Types",permalink:"/docs/network/nodes"},next:{title:"Networking Protocols",permalink:"/docs/network/network_protocols"}},l={},c=[{value:"Layers",id:"layers",level:2},{value:"Pieces cache layer(L2)",id:"pieces-cache-layerl2",level:3},{value:"Archival Storage layer(L1)",id:"archival-storage-layerl1",level:3},{value:"Piece cache types by peer roles",id:"piece-cache-types-by-peer-roles",level:2}],h={toc:c};function p(e){let{components:t,...r}=e;return(0,o.kt)("wrapper",(0,a.Z)({},h,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"To make sure no piece of the blockchain history is ever lost, no matter how large it grows, Subspace organizes farmers into a Distributed Storage Network (DSN), which is responsible for ensuring both the ephemeral and permanent availability of all chain data."),(0,o.kt)("p",null,"The DSN ensures the blockchain history is distributed across the farmer network in a way that is:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"uniform and consistent over time, where on average each piece is replicated the same number of times across the network."),(0,o.kt)("li",{parentName:"ul"},"durable, such that with high probability, no single piece may be forgotten,\nwhether accidentally or through malicious intent. "),(0,o.kt)("li",{parentName:"ul"},"retrievable, both in full and for any single piece"),(0,o.kt)("li",{parentName:"ul"},"load-balanced evenly across all farmers, allowing the overhead of serving history to remain negligible, given that some farmers may only be able to store a partial replica of the history, while others may be able to store it many times over."),(0,o.kt)("li",{parentName:"ul"},"stored in an efficiently verifiable manner, as farmers are not be expected to either synchronize or retain the full history"),(0,o.kt)("li",{parentName:"ul"},"permissionless, without any central coordination"),(0,o.kt)("li",{parentName:"ul"},"accounting for the dynamic availability of farmers and the uneven growth of the history over time.")),(0,o.kt)("p",null,"The Subspace DSN achieves the above by leveraging consistent-hashing, erasure coding, and a Kademlia Distributed Hash Table (K-DHT). To incentivize the farmer network to maintain the desired replication factor for the history, Subspace introduces a novel algorithm which dynamically adjusts the cost of on-chain storage, or blockspace, in response to changes in the supply and demand for storage. These features allow the history to bloat well beyond the storage capacity of any single farmer, while letting each farmer pledge as much or as little space as they desire. "),(0,o.kt)("h2",{id:"layers"},"Layers"),(0,o.kt)("p",null,"The DSN consists of multiple distinctive layers. While all layers serve pieces of the history, they work together to ensure different aspects of data availability, durability and efficient retrievability."),(0,o.kt)("h3",{id:"pieces-cache-layerl2"},"Pieces cache layer(L2)"),(0,o.kt)("p",null,"Pieces cache layer serves to quickly get pieces for data reconstruction and farming. The main purpose of this layer is to reduce latency of piece retrieval. Retrieval of pieces from Archival Storage requires farmers to read and decode their plotted sectors, which is a computationally intensive operation that currently takes ~1 second. In contrast, retrieval of pieces from L2 is almost instant as they are kept in memory. For this reason, the default way to acquire pieces is getting them from L2."),(0,o.kt)("p",null,"The piece cache layer stores pieces in the DHT by the proximity of piece index hash to peer ID. While any peer can store pieces in the L2 cache, at the moment we mostly rely on farmers as the most suitable candidates for pieces L2. Farmers dedicate a tiny part of their total pledged storage space to store L2 pieces. Several farmers closest to each other as peers by peer ID may store the same piece, determined by the overall storage network replication factor."),(0,o.kt)("p",null,"Piece cache layer is populated as follows:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"New segments of pieces are produced by nodes during the Archiving process. "),(0,o.kt)("li",{parentName:"ul"},"Nodes temporarily store in their cache the new segments they produce."),(0,o.kt)("li",{parentName:"ul"},"Farmers receive the segment index from the latest block header from the connected node. "),(0,o.kt)("li",{parentName:"ul"},"Farmers derive the piece index hashes from the segment index and compare their peer ID with those hashes to determine whether they should download any pieces from this segment to their L2. "),(0,o.kt)("li",{parentName:"ul"},"Farmers pull relevant pieces to their local L2 cache.")),(0,o.kt)("h3",{id:"archival-storage-layerl1"},"Archival Storage layer(L1)"),(0,o.kt)("p",null,"The Archival Storage layer is the fundamental layer responsible for permanent storage and durability of all chain data. It consists of all storage pledged by farmers that is used to store encoded pieces of chain history."),(0,o.kt)("p",null,"This layer stores the blockchain history data in the encoded form as an integral part of the ",(0,o.kt)("a",{parentName:"p",href:"/docs/category/dilithium-consensus"},"Dilithium consensus"),". It stores the pieces encoded into plot sectors in SSD files. "),(0,o.kt)("p",null,"The Archival Storage layer serves as the \u201ccold storage\u201d and guarantees the history pieces are available when they couldn't be retrieved from L2. Retrieval from Archival storage, however, consumes a moderate amount of time and resources and is expected to be used only in the rare event of L2 cache miss.\nIn most cases, the L1 layers of farmers are populated with pieces received from L2."),(0,o.kt)("h2",{id:"piece-cache-types-by-peer-roles"},"Piece cache types by peer roles"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Node cache")," contains newly archived pieces from the latest segments. It is limited to a few recent segments and older pieces are gradually replaced with new data."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Farmer cache")," contains pieces in L2 cache that is automatically populated upon receiving the new archived segment announcements. Pieces are cached according to the proximity to the farmer's peer ID.")))}p.isMDXComponent=!0}}]);