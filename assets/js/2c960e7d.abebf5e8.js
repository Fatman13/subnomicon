"use strict";(self.webpackChunkportal=self.webpackChunkportal||[]).push([[393],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var o=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,o,s=function(e,t){if(null==e)return{};var n,o,s={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var c=o.createContext({}),l=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return o.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},f=o.forwardRef((function(e,t){var n=e.components,s=e.mdxType,r=e.originalType,c=e.parentName,u=a(e,["components","mdxType","originalType","parentName"]),f=l(n),d=s,m=f["".concat(c,".").concat(d)]||f[d]||p[d]||r;return n?o.createElement(m,i(i({ref:t},u),{},{components:n})):o.createElement(m,i({ref:t},u))}));function d(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=n.length,i=new Array(r);i[0]=f;var a={};for(var c in t)hasOwnProperty.call(t,c)&&(a[c]=t[c]);a.originalType=e,a.mdxType="string"==typeof e?e:s,i[1]=a;for(var l=2;l<r;l++)i[l]=n[l];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}f.displayName="MDXCreateElement"},8321:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var o=n(7462),s=(n(7294),n(3905));const r={title:"Proof-of-Time",sidebar_position:6,description:"Proof-of-Time consensus component",keywords:["Consensus","randomness","challenge"]},i=void 0,a={unversionedId:"consensus/consensus/pot",id:"consensus/consensus/pot",title:"Proof-of-Time",description:"Proof-of-Time consensus component",source:"@site/docs/consensus/consensus/pot.md",sourceDirName:"consensus/consensus",slug:"/consensus/consensus/pot",permalink:"/docs/consensus/consensus/pot",draft:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{title:"Proof-of-Time",sidebar_position:6,description:"Proof-of-Time consensus component",keywords:["Consensus","randomness","challenge"]},sidebar:"tutorialSidebar",previous:{title:"Farming",permalink:"/docs/consensus/consensus/farming"},next:{title:"Securing Dilithium with Proof-of-Time",permalink:"/docs/consensus/consensus/pot copy"}},c={},l=[{value:"Workflow",id:"workflow",level:2},{value:"Function Choice",id:"function-choice",level:2}],u={toc:l};function p(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any energy-efficient proof system implemented in the blockchain setting suffers from the problem of costless simulation, also known as the ",(0,s.kt)("em",{parentName:"p"},"nothing-at-stake")," problem in the Proof-of-Stake context. Proofs-of-time (PoT), or sequential proofs-of-work with deterministic outputs, address this problem. PoTs have been proposed in combination with proofs-of-space, proofs-of-storage, and proof-of-stake. In Subspace, PoTs we combine with PoAS to obtain a farming dynamic that mimics the random time interval of Bitcoin's mining dynamic and prevents costless simulation while only expending a small constant amount of electricity for consensus.\nWe construct PoT on a pseudorandom permutation (PRP) function based on AES-128. The PRP takes as input a seed and key and outputs a pseudorandom number used as global randomness to challenge farmers and determine slot leaders among domain operators. For an adversary to simulate a proof-of-time, they would have to evaluate the PRP function for the same number of iterations as honest nodes. This evaluation requires expending a similar amount of computational resources."),(0,s.kt)("h2",{id:"workflow"},"Workflow"),(0,s.kt)("p",null,"The Proof-of-Time chain starts at the genesis time of the Subspace consensus chain. "),(0,s.kt)("p",null,"Every time slot, the PRP function is evaluated for a set number of iterations to generate fresh global randomness. The Timekeepers, nodes responsible for PoT evaluation, use the same initial seed and key to generate the same output. Sequentiality is achieved by chaining the output of one slot as the seed for the next slot."),(0,s.kt)("p",null,"Farmers receive the fresh global randomness every slot and scan their plots to see if they contain any chunks of history close enough to the challenge to claim the block. Farmers with the correct chunks provide a proof-of-space for those, build a block and earn rewards. The randomness is revealed a few slots in advance to ensure every farmer on the network has enough time to receive it, scan their plots and submit the proof-of-space if they win. The farmers include PoT outputs in the block header, and the PoT chain is persisted in the consensus chain in this way."),(0,s.kt)("p",null,"Every 50 blocks, entropy from the consensus chain is injected back into the PoT chain to counter any speedups gained by adversarial nodes in the previous interval. Injection also prevents an adversary from simulating a PoT chain without also having to simulate a consensus chain fork. The injection takes the PoS solution and PoT output from a deep consensus block header as the new seed for the PRP function."),(0,s.kt)("h2",{id:"function-choice"},"Function Choice"),(0,s.kt)("p",null,"We choose AES for the iterated function because there is already an extremely efficient hardware and software implementation using hardware acceleration instructions, and we don't expect a significant speedup over this."),(0,s.kt)("p",null,"Every time slot, Timekeepers publish the output of AES-128 run for a specified number of iterations. Alongside the output, they publish a set of intermediate checkpoints, currently 8, spaced uniformly. "),(0,s.kt)("p",null,"Including checkpoints allows other nodes to validate the output ~7 times faster and use ~4x less power than evaluation by leveraging instruction-level parallelism.\nOn consumer hardware, it is estimated that validating the PoT outputs expends ~2.7 kWh of electricity monthly per node, ~80000x less than PoW consensus."))}p.isMDXComponent=!0}}]);