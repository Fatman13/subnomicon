"use strict";(self.webpackChunkportal=self.webpackChunkportal||[]).push([[632],{9596:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var n=s(7624),i=s(2172);const o={title:"Plotting",sidebar_position:3,description:"Plotting Phase",keywords:["Consensus","Plotting"],last_update:{date:"02/06/2024",author:"Dariia Porechna"}},a=void 0,r={id:"consensus/consensus/plotting",title:"Plotting",description:"Plotting Phase",source:"@site/docs/consensus/consensus/plotting.md",sourceDirName:"consensus/consensus",slug:"/consensus/consensus/plotting",permalink:"/docs/consensus/consensus/plotting",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Dariia Porechna",lastUpdatedAt:1707174e3,formattedLastUpdatedAt:"Feb 5, 2024",sidebarPosition:3,frontMatter:{title:"Plotting",sidebar_position:3,description:"Plotting Phase",keywords:["Consensus","Plotting"],last_update:{date:"02/06/2024",author:"Dariia Porechna"}},sidebar:"tutorialSidebar",previous:{title:"Archiving",permalink:"/docs/consensus/consensus/archiving"},next:{title:"Farming",permalink:"/docs/consensus/consensus/farming"}},l={},c=[{value:"Proof-of-Space Encoding",id:"proof-of-space-encoding",level:2},{value:"Workflow",id:"workflow",level:2},{value:"Plot Updates",id:"plot-updates",level:2}];function h(e){const t={a:"a",annotation:"annotation",em:"em",h2:"h2",li:"li",math:"math",mn:"mn",mrow:"mrow",msup:"msup",ol:"ol",p:"p",semantics:"semantics",span:"span",strong:"strong",...(0,i.M)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["Plotting is the process of creating and maintaining plots on a disk.\nThe Plotting protocol used in ",(0,n.jsx)(t.em,{children:"Dilithium"})," is based on two core ideas: erasure coding and memory-bandwidth-bound encoding. Erasure coding helps protect the data against loss in the event of failures and network partitions. Memory-bandwidth-bound encoding is a more ecological and economical alternative to proofs-of-work while providing provable time/memory trade-offs and security guarantees. Combining these two ideas allows us to create unique and provable replicas for each farmer that are difficult to fake with computation or to compress. This scheme also makes scanning and verifying the plots easier, ensuring the history data is recoverable."]}),"\n",(0,n.jsx)(t.p,{children:"During this phase, the pieces are gathered and organized into a plot of several sectors. Each sector contains an encoded replica of a uniformly random sample of pieces across all archived history. This sampling ensures that the data is distributed among the farmers proportionally to their pledged disk space and replicated evenly."}),"\n",(0,n.jsx)(t.h2,{id:"proof-of-space-encoding",children:"Proof-of-Space Encoding"}),"\n",(0,n.jsxs)(t.p,{children:["The memory-bandwidth bound encoding construction comes from the paper ",(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.a,{href:"https://www.semanticscholar.org/paper/Beyond-Hellman's-Time-Memory-Trade-Offs-with-to-of-Abusalah-Alwen/39e70d67eeb5ce140171f6d0629daec3b54d74f3",children:"Beyond Hellman's Time-Memory Trade-Offs with Applications to Proofs of Space"})})," which is a part of the ",(0,n.jsx)(t.a,{href:"https://www.chia.net/",children:"Chia"})," protocol. We adopt a custom implementation of the Chia Proof-of-Space plotting function as a memory-bandwidth-bound function to encode, or \u201cmask,\u201d the pieces in the farmer plot."]}),"\n",(0,n.jsxs)(t.p,{children:["In short, the PoS plotter generates a table of permuted outputs from a set of random functions. The table size is determined by a memory bandwidth requirement parameter, ",(0,n.jsx)(t.em,{children:"k"}),", set to 20, and the random functions are determined by a ",(0,n.jsx)(t.em,{children:"seed"}),". When challenged at an ",(0,n.jsx)(t.em,{children:"index"}),", the table outputs a short ",(0,n.jsx)(t.em,{children:"proof-of-space"})," that can be efficiently verified.\nWe do not use the proof-of-space directly to verify that a farmer has pledged a certain amount of space, as Chia does. Instead, we use it to prove that a farmer utilized the required memory bandwidth for encoding the plot."]}),"\n",(0,n.jsxs)("div",{align:"center",children:[(0,n.jsx)("img",{src:"/img/PoS_Table-light.svg#gh-light-mode-only",alt:"PoS_Table"}),(0,n.jsx)("img",{src:"/img/PoS_Table-dark.svg#gh-dark-mode-only",alt:"PoS_Table"})]}),"\n",(0,n.jsx)(t.h2,{id:"workflow",children:"Workflow"}),"\n",(0,n.jsx)(t.p,{children:"A plot can cover the entire disk or span across multiple disks, and there is no limit to the amount of storage a farmer can pledge to the network. Plots consist of equally-sized sectors, currently around 1 GiB each. Each sector is a pseudorandom selection of 1,000 pieces, uniformly sampled throughout history up to that point. For example, if the farmer creates a new sector when the history consists of 50,000 pieces (50 GiB), the 1,000 pieces for this sector will be a uniform selection from the existing 50,000 pieces."}),"\n",(0,n.jsx)(t.p,{children:"In addition, the farmer must save the current history size, as it will determine the point in the future when the sector will need to be updated with newer pieces."}),"\n",(0,n.jsxs)("div",{align:"center",children:[(0,n.jsx)("img",{src:"/img/Raw_Sector-light.svg#gh-light-mode-only",alt:"Raw_Sector"}),(0,n.jsx)("img",{src:"/img/Raw_Sector-dark.svg#gh-dark-mode-only",alt:"Raw_Sector"})]}),"\n",(0,n.jsx)(t.p,{children:"Once the farmer has obtained all 1,000 pieces for this sector from the network, they can create an encoded replica. Only the piece\u2019s historical data, the record part, is encoded. The KZG commitment and witness included in a piece are saved separately in the sector metadata, as they will be needed later for farming."}),"\n",(0,n.jsx)(t.p,{children:"For each record, the Plotting algorithm performs the following steps in memory:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Erasure code (extend) the record data by interpolating a polynomial over chunks of the record."}),"\n",(0,n.jsxs)(t.li,{children:["Derive a unique pseudorandom and verifiable ",(0,n.jsx)(t.em,{children:"seed"}),"."]}),"\n",(0,n.jsxs)(t.li,{children:["Based on this ",(0,n.jsx)(t.em,{children:"seed"}),", generate a proof-of-space table using memory bandwidth resources set by the global protocol memory requirement parameter ",(0,n.jsx)(t.em,{children:"k"}),". This memory-intensive computation prevents malicious farmers from creating replicas after the new block challenge is announced, making it more rational for them to store the replica rather than try to compute it on the fly every time."]}),"\n",(0,n.jsxs)(t.li,{children:["Query the generated table for enough (",(0,n.jsxs)(t.span,{className:"katex",children:[(0,n.jsx)(t.span,{className:"katex-mathml",children:(0,n.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(t.semantics,{children:[(0,n.jsx)(t.mrow,{children:(0,n.jsxs)(t.msup,{children:[(0,n.jsx)(t.mn,{children:"2"}),(0,n.jsx)(t.mn,{children:"15"})]})}),(0,n.jsx)(t.annotation,{encoding:"application/x-tex",children:"2^{15}"})]})})}),(0,n.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(t.span,{className:"base",children:[(0,n.jsx)(t.span,{className:"strut",style:{height:"0.8141em"}}),(0,n.jsxs)(t.span,{className:"mord",children:[(0,n.jsx)(t.span,{className:"mord",children:"2"}),(0,n.jsx)(t.span,{className:"msupsub",children:(0,n.jsx)(t.span,{className:"vlist-t",children:(0,n.jsx)(t.span,{className:"vlist-r",children:(0,n.jsx)(t.span,{className:"vlist",style:{height:"0.8141em"},children:(0,n.jsxs)(t.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,n.jsx)(t.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(t.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(t.span,{className:"mord mtight",children:(0,n.jsx)(t.span,{className:"mord mtight",children:"15"})})})]})})})})})]})]})})]}),") proof-of-space values to mask every chunk of the record."]}),"\n"]}),"\n",(0,n.jsxs)("div",{align:"center",children:[(0,n.jsx)("img",{src:"/img/PoS_Lookup-light.svg#gh-light-mode-only",alt:"PoS_Lookup"}),(0,n.jsx)("img",{src:"/img/PoS_Lookup-dark.svg#gh-dark-mode-only",alt:"PoS_Lookup"})]}),"\n",(0,n.jsxs)(t.ol,{start:"5",children:["\n",(0,n.jsx)(t.li,{children:"Encode each extended record chunk by XOR-masking it with the corresponding proof-of-space value."}),"\n"]}),"\n",(0,n.jsxs)("div",{align:"center",children:[(0,n.jsx)("img",{src:"/img/Piece_Encoding-light.svg#gh-light-mode-only",alt:"Piece_Encoding"}),(0,n.jsx)("img",{src:"/img/Piece_Encoding-dark.svg#gh-dark-mode-only",alt:"Piece_Encoding"})]}),"\n",(0,n.jsx)(t.p,{children:"After all records in the sector have been encoded as described, the farmer spreads them into s-buckets chunk-wise. Ultimately, each bucket will contain chunks from all records. The first bucket will have the first chunks of each record; the second bucket will have the second chunks, and so on. The s-buckets are then written to disk, and the plotting process of the sector is complete in a single write operation."}),"\n",(0,n.jsxs)("div",{align:"center",children:[(0,n.jsx)("img",{src:"/img/Encoded_Sector-light.svg#gh-light-mode-only",alt:"Encoded_Sector"}),(0,n.jsx)("img",{src:"/img/Encoded_Sector-dark.svg#gh-dark-mode-only",alt:"Encoded_Sector"})]}),"\n",(0,n.jsx)(t.p,{children:"Each bucket represents a potential winning ticket in the block proposer lottery. For each challenge, a farmer will scan one s-bucket containing one chunk of each record they store in a sector and see whether any of them are eligible to win a block."}),"\n",(0,n.jsx)(t.p,{children:"As a result, a farmer has a unique encoded replica that is difficult to compress or compute on demand. An economically rational farmer is incentivized to store as many honestly encoded replicas as possible to maximize their chances of winning a block."}),"\n",(0,n.jsx)(t.h2,{id:"plot-updates",children:"Plot Updates"}),"\n",(0,n.jsx)(t.p,{children:"As the chain grows, we need a way to ensure that new data is replicated as much as older data in blockchain history. To keep the replication factor constant, the farmers must periodically update their plots by repopulating sectors with a new selection of pieces.\nRecall that when plotting a sector, the farmer saves the history size at the time, and it determines a point in the future when the sector will expire. The expiry point is determined by the history size at the time the sector was plotted and is randomly assigned to happen sometime before the history size quadruples (i.e., if a farmer plotted this sector when the history size was 50 GiB, the expiry point will be before history reaches 200 GiB)."}),"\n",(0,n.jsx)(t.p,{children:"When a sector reaches its expiry point, the block proposer challenge solutions coming from this sector will no longer be accepted by other peers, incentivizing the farmer to update their plot. The farmer erases the expired sector and repeats the Plotting process anew, replicating a fresh history sample. Each replotting creates a new sector in memory and saves it to disk in a single write operation."}),"\n",(0,n.jsxs)("div",{align:"center",children:[(0,n.jsx)("img",{src:"/img/Replotting-light.svg#gh-light-mode-only",alt:"Replotting"}),(0,n.jsx)("img",{src:"/img/Replotting-dark.svg#gh-dark-mode-only",alt:"Replotting"})]}),"\n",(0,n.jsx)(t.p,{children:"In a plot spanning multiple gigabytes, the sectors will be updated randomly, one at a time, so replotting is amortized over a long period. There is never a moment when a farmer needs to erase and re-create their whole plot and miss out on challenges. The plot refreshing will be practically invisible to the farmer and allow their uninterrupted participation in consensus."}),"\n",(0,n.jsxs)(t.p,{children:["The bigger the chain grows and the longer the farmer participates in the network, the less frequent the replotting on their disks will be. After genesis Subspace will seed the network with 20 GiB of history, which means that farmers who join after the seeding will start plotting with initial history size of 160 segments.\nAssuming a 1 TB SSD plot, a farmer will on average need to replot 3.5 TB of data by the time the chain history reaches 1TB in size, 6.2 TB of data by the time history reaches 10 TiB and 8 TB by the time history reaches 50 TiB. Given a common TBW (Total Bytes Written) for consumer grade 1 TB SSDs of 300-600 TB, Subspace farming requires below 3% of the SSD's total endurance to farm over several years (for comparison, Ethereum's full chain data size is ~17 TiB as of January 2024 via ",(0,n.jsx)(t.a,{href:"https://etherscan.io/chartsync/chainarchive",children:"Etherscan"}),")."]}),"\n",(0,n.jsxs)("div",{align:"center",children:[(0,n.jsx)("img",{src:"/img/Replottingby10TiB-light.svg#gh-light-mode-only",alt:"Replotting_by_10TiB"}),(0,n.jsx)("img",{src:"/img/Replottingby10TiB-dark.svg#gh-dark-mode-only",alt:"Replotting_by_10TiB"})]}),"\n",(0,n.jsx)(t.p,{children:"The graphic shows the average TB replotted on a 1 TB SSD over the course of chain growth from genesis to 10 TiB (40 960 archived segments). The growth of the amount of data replotted slows down as the chain grows."})]})}function d(e={}){const{wrapper:t}={...(0,i.M)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},2172:(e,t,s)=>{s.d(t,{I:()=>r,M:()=>a});var n=s(1504);const i={},o=n.createContext(i);function a(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);