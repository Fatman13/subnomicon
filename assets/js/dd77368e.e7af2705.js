"use strict";(self.webpackChunkportal=self.webpackChunkportal||[]).push([[152],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>p});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),c=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=c(e.components);return o.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),h=c(n),p=a,m=h["".concat(s,".").concat(p)]||h[p]||d[p]||i;return n?o.createElement(m,r(r({ref:t},u),{},{components:n})):o.createElement(m,r({ref:t},u))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var c=2;c<i;c++)r[c]=n[c];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},3522:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var o=n(7462),a=(n(7294),n(3905));const i={title:"Data Flow",sidebar_position:3,description:"Lifecycle of Data on Subspace Blockchain",keywords:["Consensus","Data","Storage","Transactions"]},r=void 0,l={unversionedId:"consensus/data_flow",id:"consensus/data_flow",title:"Data Flow",description:"Lifecycle of Data on Subspace Blockchain",source:"@site/docs/consensus/data_flow.md",sourceDirName:"consensus",slug:"/consensus/data_flow",permalink:"/docs/consensus/data_flow",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Data Flow",sidebar_position:3,description:"Lifecycle of Data on Subspace Blockchain",keywords:["Consensus","Data","Storage","Transactions"]},sidebar:"tutorialSidebar",previous:{title:"Genesis",permalink:"/docs/consensus/genesis"},next:{title:"Proof-of-Archival-Storage",permalink:"/docs/category/proof-of-archival-storage"}},s={},c=[{value:"Block Structure",id:"block-structure",level:2},{value:"Consensus Chain Block Header",id:"consensus-chain-block-header",level:2},{value:"Domain Bundle",id:"domain-bundle",level:2},{value:"Domain Block",id:"domain-block",level:2}],u={toc:c};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"From the moment a transaction is submitted to the Subspace blockchain to the point it is permanently archived, data goes through several stages:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Transaction is validated and included in a consensus chain block directly or through inclusions of domain bundles"),(0,a.kt)("li",{parentName:"ol"},"Transactions and bundles in the block are executed, activating a global and domain state change"),(0,a.kt)("li",{parentName:"ol"},"When that block reaches certain depth (currently 100 blocks) it is archived following the Archiving protocol alongside other blocks. At this point it irreversibly becomes a part of Archival History of chain"),(0,a.kt)("li",{parentName:"ol"},"Newly archived pieces are added to farmer caches through the Distributed Storage Network and replicated multiple times throughout the network"),(0,a.kt)("li",{parentName:"ol"},"From there they are encoded into farmer plots on disk for permanent storage, following the Plotting protocol"),(0,a.kt)("li",{parentName:"ol"},"When requested by a client, the original data is reconstructed from archived pieces on the fly")),(0,a.kt)("h2",{id:"block-structure"},"Block Structure"),(0,a.kt)("p",null,'A Subspace consensus chain block follows the general structure of a common block: it consists of a body and a header. The consensus chain block header contains metadata about the block allowing verification of validity of the consensus chain. The body contains transactions and domain bundles. A domain bundle is a deterministically ordered set multiple transactions in a particular domain (e.g. EVM contract calls) grouped together for efficient execution. Each domain bundle can be seen as "a block inside a block" with its own bundle header containing information about the domain, the bundle producer etc. Any given consensus chain block may contain many bundles from different domains without burdening the consensus nodes. Consensus nodes are responsible solely for checking if bundles are well-formed and packaging them within a block. Consensus nodes do not execute any of the computation inside the bundles.'),(0,a.kt)("h2",{id:"consensus-chain-block-header"},"Consensus Chain Block Header"),(0,a.kt)("p",null,"In Subspace, the consensus block header contains:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The block number in the chain of blocks"),(0,a.kt)("li",{parentName:"ul"},"The hash of the parent block"),(0,a.kt)("li",{parentName:"ul"},"The Merkle root of the trie of extrinsics included in this block"),(0,a.kt)("li",{parentName:"ul"},"The Merkle root of the state trie after processing this block"),(0,a.kt)("li",{parentName:"ul"},"The time slot number claimed by the block producer"),(0,a.kt)("li",{parentName:"ul"},"The global randomness at the claimed time slot derived from the proof-of-time chain"),(0,a.kt)("li",{parentName:"ul"},"The solution to the slot challenge for the claimed time slot. The solution includes a winning chunk of history, a proof-of-space for the farmer's plot and KZG witness that the winning chunk is indeed a part of the archival history at the claimed height"),(0,a.kt)("li",{parentName:"ul"},"The solution range used to find the winning chunk of history"),(0,a.kt)("li",{parentName:"ul"},"The signature of the block producer over the header")),(0,a.kt)("h2",{id:"domain-bundle"},"Domain Bundle"),(0,a.kt)("p",null,"A bundle contains multiple transactions in a particular domain (e.g. EVM contract calls) grouped together for efficient execution, propagation and inclusion in blocks. In Subspace, a bundle contains a signed header and a list of transactions. A bundle header contains:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The domain ID (e.g. EVM)"),(0,a.kt)("li",{parentName:"ul"},"The operator ID of the bundle producer"),(0,a.kt)("li",{parentName:"ul"},"The Merkle root of the trie of transactions included in this bundle"),(0,a.kt)("li",{parentName:"ul"},"Execution receipt that should extend the receipt chain"),(0,a.kt)("li",{parentName:"ul"},"The size of the bundle body in bytes, used to calculate the storage cost"),(0,a.kt)("li",{parentName:"ul"},"The total estimated weight of all extrinsics in the bundle, used to prevent overloading the bundle with compute."),(0,a.kt)("li",{parentName:"ul"},"The time slot claimed by the bundle"),(0,a.kt)("li",{parentName:"ul"},"The global randomness at the claimed time slot derived from the proof-of-time chain"),(0,a.kt)("li",{parentName:"ul"},"The proof-of-election of the operator as bundle producer for the claimed time slot based on slot challenge and operator's stake in the current epoch")),(0,a.kt)("h2",{id:"domain-block"},"Domain Block"),(0,a.kt)("p",null,"Each domain is its own application specific blockchain (app-chain), that relies on the consensus chain for data availability, and settlement.\nDomain chains consist of domain blocks, each containing solely the bundles relevant to this specific domain and disregards any transactions concerning other domains. Domain chains have separate namespaced execution environments, while still receiving shared security and interoperability from the consensus chain."))}d.isMDXComponent=!0}}]);