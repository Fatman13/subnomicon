"use strict";(self.webpackChunkportal=self.webpackChunkportal||[]).push([[393],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var o=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,s=function(e,t){if(null==e)return{};var n,o,s={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var c=o.createContext({}),l=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=l(e.components);return o.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},f=o.forwardRef((function(e,t){var n=e.components,s=e.mdxType,r=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),f=l(n),d=s,h=f["".concat(c,".").concat(d)]||f[d]||p[d]||r;return n?o.createElement(h,a(a({ref:t},u),{},{components:n})):o.createElement(h,a({ref:t},u))}));function d(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=n.length,a=new Array(r);a[0]=f;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:s,a[1]=i;for(var l=2;l<r;l++)a[l]=n[l];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}f.displayName="MDXCreateElement"},8321:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var o=n(7462),s=(n(7294),n(3905));const r={title:"Proof-of-Time",sidebar_position:6,description:"Proof-of-Time consensus component",keywords:["Consensus","randomness","challenge"]},a=void 0,i={unversionedId:"consensus/consensus/pot",id:"consensus/consensus/pot",title:"Proof-of-Time",description:"Proof-of-Time consensus component",source:"@site/docs/consensus/consensus/pot.md",sourceDirName:"consensus/consensus",slug:"/consensus/consensus/pot",permalink:"/docs/consensus/consensus/pot",draft:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{title:"Proof-of-Time",sidebar_position:6,description:"Proof-of-Time consensus component",keywords:["Consensus","randomness","challenge"]},sidebar:"tutorialSidebar",previous:{title:"Farming",permalink:"/docs/consensus/consensus/farming"},next:{title:"Security",permalink:"/docs/consensus/security"}},c={},l=[{value:"Workflow",id:"workflow",level:2},{value:"Function Choice",id:"function-choice",level:2}],u={toc:l};function p(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any energy-efficient proof system implemented in the blockchain setting suffers from the problem of costless simulation, also known as the ",(0,s.kt)("em",{parentName:"p"},"nothing-at-stake")," problem in Proof-of-Stake context. Proofs-of-time (PoT), or sequential proofs-of-work with deterministic outputs, address this problem. PoTs have been proposed in combination with proofs-of-space, proofs-of-storage, and proof-of-stake. In Subspace, PoTs we combine them with PoAS to obtain a farming dynamic that mimics the random time interval of Bitcoin\u2019s mining dynamic and prevents costless simulation while only expending a small constant amount of electricity for consensus.\nWe construct PoT on a pseudorandom permutation (PRP) function based on AES-128. The PRP takes as input a seed and key and outputs a pseudorandom number used as global randomness to challenge farmers and determine slot leaders among domain operators. For an adversary to simulate a proof-of-time, they would have to evaluate the PRP function for the same number of iterations as honest nodes. This requires expending a similar amount of computational resources."),(0,s.kt)("h2",{id:"workflow"},"Workflow"),(0,s.kt)("p",null,"The Proof-of-Time chain starts at the genesis time of the Subspace consensus chain. "),(0,s.kt)("p",null,"Every slot, the PRP function is evaluated for a set number of iterations to generate fresh global randomness. The Timekeepers, nodes responsible for PoT evaluation, use the same initial seed and key to generate the same output. Sequentiality is achieved by chaining the output of one slot as the seed for the next slot."),(0,s.kt)("p",null,"Every slot, farmers receive the fresh global randomness and audit their plots to see if they contain any chunks of history close enough to the challenge to claim the block. Farmers that have the correct chunks provide a proof-of-space for those, build a block and earn rewards. The randomness is revealed a few slots in advance to make sure every farmer on the network has enough time to receive it, audit their plots and submit the proof-of-space in case they win. The farmers include PoT outputs in the block header and the PoT chain is persisted in the consensus chain in this way."),(0,s.kt)("p",null,"Every interval of 18 blocks, randomness from the consensus chain is injected back to the PoT chain to counter any speedups gained by adversarial nodes in the previous interval. This also prevents an adversary from simulation a PoT chain without also having to simulate a consensus chain fork. The injection takes the hash of a deep consensus block header as the new seed for the PRP function."),(0,s.kt)("h2",{id:"function-choice"},"Function Choice"),(0,s.kt)("p",null,"We choose AES for the iterated function because there is already an extremely efficient hardware and software implementation using hardware acceleration instructions, and we don't expect a significant speedup over this.\nEvery time slot Timekeepers publish the output of AES-128 run for a specified number of iterations. Alongside the output, they publish a set of intermediate checkpoints, currently 8, spaced uniformly. "),(0,s.kt)("p",null,"The inclusion of checkpoints allows other nodes to validate the output ~6.5 times faster and using ~4x less power than evaluation by leveraging instruction level parallelism.\nOn consumer hardware it is estimated that validating the PoT outputs expends ~2.7 kWh of electricity monthly per node, ~80000x less than PoW consensus."))}p.isMDXComponent=!0}}]);