"use strict";(self.webpackChunkportal=self.webpackChunkportal||[]).push([[660],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=o.createContext({}),l=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=l(e.components);return o.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=l(n),u=r,f=h["".concat(c,".").concat(u)]||h[u]||p[u]||a;return n?o.createElement(f,i(i({ref:t},d),{},{components:n})):o.createElement(f,i({ref:t},d))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},582:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var o=n(7462),r=(n(7294),n(3905));const a={title:"Networking Protocols",sidebar_position:3,description:"Subspace P2P networking protocols",keywords:["p2p","Network","Node","Peer"]},i=void 0,s={unversionedId:"network/network_protocols",id:"network/network_protocols",title:"Networking Protocols",description:"Subspace P2P networking protocols",source:"@site/docs/network/network_protocols.md",sourceDirName:"network",slug:"/network/network_protocols",permalink:"/docs/network/network_protocols",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Networking Protocols",sidebar_position:3,description:"Subspace P2P networking protocols",keywords:["p2p","Network","Node","Peer"]},sidebar:"tutorialSidebar",previous:{title:"Distributed Storage Network",permalink:"/docs/network/dsn"},next:{title:"Decoupled Execution",permalink:"/docs/category/decoupled-execution"}},c={},l=[{value:"Transaction Propagation",id:"transaction-propagation",level:2},{value:"Block and Bundle Relay",id:"block-and-bundle-relay",level:2},{value:"Synchronization",id:"synchronization",level:2},{value:"DSN Sync",id:"dsn-sync",level:3},{value:"Piece Retrieval",id:"piece-retrieval",level:2}],d={toc:l};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Subspace networking stack is based on libp2p and implements Subspace-specific protocols like piece and archived segment header retrieval. The networking layers handles a variety of essential tasks like:"),(0,r.kt)("h2",{id:"transaction-propagation"},"Transaction Propagation"),(0,r.kt)("p",null,"Transactions are propagated across the network to ensure nodes have a consistent view of unconfirmed transactions. The Subspace Network uses a gossip mechanism to propagate transactions to peers. When a node receives a new transaction, it first validates the transaction and if valid, adds it to their transaction pool and broadcasts it to all of its directly connected peers. As soon as a connected peer receives the transaction, they verify its validity. If deemed valid, they retain a copy and share it with all their connected peers, excluding the one from which it was received. Consequently, the transaction disseminates from its source, spreading throughout the network, like a flood, ensuring every node gets a copy. "),(0,r.kt)("h2",{id:"block-and-bundle-relay"},"Block and Bundle Relay"),(0,r.kt)("p",null,"When a new block is built it has to be propagated across the network as quickly as possible. To achieve efficient block propagation Subspace adopts a notion of compact blocks. Since the substantial portion of the block size is the body of transactions included in it and each of the transactions was already broadcast to nodes beforehand, rebroadcasting the full body again is superfluous. "),(0,r.kt)("p",null,"When a node receives a new block, it first validates the block header and transactions. If valid, it builds a compact block message containing just the block header and transaction IDs. This compact block is then gossiped across the network. When a peer receives this compact block, it checks if it has all the referenced transactions in its pool. If any transactions are missing, it requests the full transactions from the broadcasting node. This allows fast block propagation while minimizing unnecessary transaction data transfer across the network."),(0,r.kt)("p",null,"A similar mechanism is used for bundle relay as well where a compact bundle is built containing just the bundle header and transaction IDs. This allows fast dissemination of new bundles throughout the network."),(0,r.kt)("h2",{id:"synchronization"},"Synchronization"),(0,r.kt)("p",null,"Subspace Network employs an adaptive synchronization protocol to efficiently sync nodes to the latest state of the network. The adaptive protocol chooses between DSN sync and block sync based on how deep the node is behind."),(0,r.kt)("h3",{id:"dsn-sync"},"DSN Sync"),(0,r.kt)("p",null,"DSN Sync is a specialized sync method made possible by the unique way Subspace archives the chain data and stores in the Distributed Storage Network (DSN).\nThe DSN sync is attempted every time a node joins the network or detects it is more than a hundred blocks behind the network tip. The node first gathers information from its peers about the latest archived segment headers to see whether there has been any new data archived since it last synced. If there are new segments available, it downloads the headers and verifies whether they form a chain. Once verified, it downloads full segment data from the DSN, verifies commitments and locally reconstructs blocks from pieces. The DSN Sync allows a node to sync hundreds or thousands of blocks in one shot by downloading archived data directly from the DSN rather than fetching individual blocks from peers.\nOnce the node has downloaded all missing segments and imported archived history, it then switches to syncing the recent blocks from other nodes until it reaches the network tip."),(0,r.kt)("h2",{id:"piece-retrieval"},"Piece Retrieval"),(0,r.kt)("p",null,"Another essential protocol implemented by the Subspace networking stack is piece retrieval. When a node need pieces for plotting or when requested by a client application, it sends a request to peers whose ID is close to the piece index hash. With a high probability, the peer who receives the request will have the piece available in piece cache and can respond with the piece data. In a rare case when none of the peers have the piece, the request falls back to asking them to decode the piece from their plots.\nThe piece retrieval protocol allows nodes to efficiently retrieve history pieces from the network with mininum hops."))}p.isMDXComponent=!0}}]);