"use strict";(self.webpackChunkportal=self.webpackChunkportal||[]).push([[170],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>p});var o=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,i=function(e,n){if(null==e)return{};var t,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=o.createContext({}),c=function(e){var n=o.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=c(e.components);return o.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},h=o.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),h=c(t),p=i,m=h["".concat(s,".").concat(p)]||h[p]||u[p]||a;return t?o.createElement(m,r(r({ref:n},d),{},{components:t})):o.createElement(m,r({ref:n},d))}));function p(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,r=new Array(a);r[0]=h;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var c=2;c<a;c++)r[c]=t[c];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}h.displayName="MDXCreateElement"},1113:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var o=t(7462),i=(t(7294),t(3905));const a={title:"General Workflow",sidebar_position:1,description:"Domains Workflow",keywords:["DecEx","Domains","Staking"]},r=void 0,l={unversionedId:"decex/domains/workflow",id:"decex/domains/workflow",title:"General Workflow",description:"Domains Workflow",source:"@site/docs/decex/domains/workflow.md",sourceDirName:"decex/domains",slug:"/decex/domains/workflow",permalink:"/docs/decex/domains/workflow",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"General Workflow",sidebar_position:1,description:"Domains Workflow",keywords:["DecEx","Domains","Staking"]},sidebar:"tutorialSidebar",previous:{title:"Domains",permalink:"/docs/category/domains"},next:{title:"Nova EVM",permalink:"/docs/decex/domains/evm"}},s={},c=[{value:"Domain Creation",id:"domain-creation",level:2},{value:"Operator Staking",id:"operator-staking",level:2},{value:"Domain Transactions",id:"domain-transactions",level:2},{value:"Leader Election",id:"leader-election",level:2},{value:"Bundle Production",id:"bundle-production",level:2},{value:"Bundle Verification",id:"bundle-verification",level:2},{value:"Bundle Inclusion in the Consensus Block",id:"bundle-inclusion-in-the-consensus-block",level:2},{value:"Domain Block Execution",id:"domain-block-execution",level:2},{value:"Challenging Operators",id:"challenging-operators",level:2}],d={toc:c};function u(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,o.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The following is an overview of domain sub-protocols. The existence of domains assumes a live consensus chain with at least one farmer and block production. On its own, the consensus chain will only issue rewards to farmers and allow for balance transfers of SSC. "),(0,i.kt)("h2",{id:"domain-creation"},"Domain Creation"),(0,i.kt)("p",null,"The sudo user registers the first domain runtime and uploads its WASM runtime directly into the chain state. "),(0,i.kt)("p",null,"The sudo user then instantiates the first domain on the previously registered domain runtime. Instantiation includes a genesis config, from which a chainspec and a genesis block for this domain are built. The domain genesis config includes domain name, runtime code and other specific configuration items, such as maximum block size and weight and number of bundles in each slot and block."),(0,i.kt)("h2",{id:"operator-staking"},"Operator Staking"),(0,i.kt)("p",null,"After a domain is instantiated, anyone may deposit SSC and stake as an operator of this domain, allowing them to participate in the leader election to produce bundles and execute domain blocks.\nThey do this by submitting a registration extrinsic with a staking deposit, targeting the first domain instance. They will be eligible to participate in the leader election on the next stake epoch. "),(0,i.kt)("h2",{id:"domain-transactions"},"Domain Transactions"),(0,i.kt)("p",null,"The users of the first domain may now produce extrinsics (transactions) and submit them to operators on the domain's subnet."),(0,i.kt)("p",null,"When pre-validating extrinsics, operators only check to ensure the extrinsic is well-formed and that the user can afford the blockspace storage fee. They have yet to attempt to execute the transaction to determine if the execution weight fees can be paid."),(0,i.kt)("h2",{id:"leader-election"},"Leader Election"),(0,i.kt)("p",null,"For each time slot, all registered operators will attempt to solve a VRF puzzle with a success probability defined in the domain genesis config. To do so, they sign the slot challenge and check if the result is below the desired threshold. The operator will gather transactions from the pool and produce a new domain bundle if elected. "),(0,i.kt)("h2",{id:"bundle-production"},"Bundle Production"),(0,i.kt)("p",null,"To produce a new bundle, the operator has to include: "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"a proof of election showing that they are a leader for this time slot, "),(0,i.kt)("li",{parentName:"ul"},"an Execution Receipt that either extends or confirms the previous domain block tracked on the consensus chain, "),(0,i.kt)("li",{parentName:"ul"},"all bundle extrinsics that fall within the operator's portion of the extrinsic pool. ")),(0,i.kt)("p",null,"The bundle is then broadcast on the consensus chain gossip network. "),(0,i.kt)("h2",{id:"bundle-verification"},"Bundle Verification"),(0,i.kt)("p",null,"All consensus nodes receiving the bundle will verify that it is well-formed. The bundle header should include a valid proof of election based on the stake distribution for this epoch, and the Execution Receipt should build on the current execution chain block tree for this domain.\nConsensus nodes broadcast all valid bundles to their peers and place them within their local extrinsic pool."),(0,i.kt)("h2",{id:"bundle-inclusion-in-the-consensus-block"},"Bundle Inclusion in the Consensus Block"),(0,i.kt)("p",null,"When a consensus node is elected to produce a new consensus chain block, it will include as many valid domain bundles as will fit into the block and broadcast the block on the consensus network. Other nodes will only accept blocks that include valid bundles. "),(0,i.kt)("h2",{id:"domain-block-execution"},"Domain Block Execution"),(0,i.kt)("p",null,"Given a valid consensus block with at least one domain bundle, the operator may build and execute the corresponding domain block.\nOn block execution, each bundle header will be applied to the consensus chain state, and each extrinsic will be added to the domain's execution inbox.\nExtrinsics will be deduplicated, grouped by the sender, and deterministically shuffled to mitigate the ability of operators to extract value from users by re-ordering or inserting extrinsics (MEV).\nThe domain block will then be carefully executed, one extrinsic at a time, allowing the operator to produce an Execution Receipt."),(0,i.kt)("h2",{id:"challenging-operators"},"Challenging Operators"),(0,i.kt)("p",null,"Any node who observes an Execution Receipt within any bundle for any consensus chain block that differs from what they produced locally has detected fraud. They will produce an extrinsic with a fraud proof to handle the fraud. If the fraud proof is valid, it will be included in the consensus chain, which will prune the Execution Receipt in question and all children from the block tree and slash all related operators."))}u.isMDXComponent=!0}}]);