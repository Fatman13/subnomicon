"use strict";(self.webpackChunkportal=self.webpackChunkportal||[]).push([[176],{6892:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>h,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var t=n(7624),s=n(2172);const o={title:"Overview",sidebar_position:1,description:"Dilithium Consensus Overview",keywords:["Consensus","Dilithium"]},r=void 0,a={id:"consensus/overview",title:"Overview",description:"Dilithium Consensus Overview",source:"@site/docs/consensus/overview.md",sourceDirName:"consensus",slug:"/consensus/overview",permalink:"/docs/consensus/overview",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Overview",sidebar_position:1,description:"Dilithium Consensus Overview",keywords:["Consensus","Dilithium"]},sidebar:"tutorialSidebar",previous:{title:"Consensus",permalink:"/docs/category/consensus"},next:{title:"Genesis",permalink:"/docs/consensus/genesis"}},h={},c=[{value:"Technical Overview",id:"technical-overview",level:2}];function l(e){const i={a:"a",em:"em",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.M)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["Subspace is powered by ",(0,t.jsx)(i.em,{children:"Dilithium"})," - a lightweight and secure consensus mechanism that is environmentally friendly, permissionless, and fair. ",(0,t.jsx)(i.em,{children:"Dilithium"})," is a Proof-of-Archival-Storage (PoAS), Nakamoto-style consensus protocol based on proofs of storing the blockchain history."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"Dilithium"})," is a second-generation PoAS consensus algorithm that uses erasure coding and KZG commitments for distributed archiving while combining polynomial encoding with an ASIC-resistant Proof-of-Space for plotting and drawing block challenges from AES-based Proof-of-Time. The protocol represents a significant step forward in security and user experience for Subspace Network participants. ",(0,t.jsx)(i.em,{children:"Dilithium"})," is also designed to be SSD-friendly, further enhancing energy efficiency and decentralization."]}),"\n",(0,t.jsxs)(i.p,{children:["For those familiar with our initial consensus design,\xa0",(0,t.jsx)(i.em,{children:"Dilithium"}),"\xa0fulfills all the fundamental ideas described in the original\xa0",(0,t.jsx)(i.a,{href:"https://subspace.network/news/subspace-network-whitepaper",children:"whitepaper"}),"\xa0but applies them better."]}),"\n",(0,t.jsx)(i.p,{children:"In PoAS, farmers (not miners) store as many unique pieces of the blockchain history as their disk space allows. PoAS incentivizes the storage of the blockchain history, resolving the key mechanism design failure which has hindered scalability and led to centralization within Proof-of-Storage blockchains like Filecoin and Chia. Since PoAS consensus is based on storage, rather than compute power or wealth, it is eco-friendly while remaining accessible to ordinary people with available disk space. This allows it to combine the high security of Bitcoin-style Proof-of-Work with the energy-efficiency of Ethereum-style Proof-of-Stake. It also turns out that PoAS provides the basis for a more generic solution to the problem of blockchain bloat."}),"\n",(0,t.jsx)(i.h2,{id:"technical-overview",children:"Technical Overview"}),"\n",(0,t.jsx)(i.p,{children:"Similar to other Proof-of-Storage projects, the resource that participants allocate to secure the Subspace network is\ndisk space. As a resource, disk space is widely distributed and in general the notion of an ASIC does not apply to\nstorage. As such, the Subspace protocol has the potential to be highly decentralized and more fair than\nother blockchain protocols."}),"\n",(0,t.jsxs)(i.p,{children:['Unlike other Proof-of-Storage projects where the data stored is some "cryptographic data", uniquely generated per\nparticipant, in Subspace the participants, called farmers, store the blockchain history. Not only that in Subspace we\nhave found a way to store "useful data", but we also solve the so-called ',(0,t.jsx)(i.em,{children:"farmer's dilemma"}),", where a rational farmer\nprefers to use her disk space to store more (non-useful) cryptographic data, consequentially not storing the current\nstate or the blockchain history -- a strategy that if followed by all farmers, will lead to a unfunctional network."]}),"\n",(0,t.jsx)(i.p,{children:"Formally, PoAS is a three phase protocol, consisting of:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["a recurring deterministic ",(0,t.jsx)(i.strong,{children:"Archiving"})," phase done by all nodes"]}),"\n",(0,t.jsxs)(i.li,{children:["a unique setup or ",(0,t.jsx)(i.strong,{children:"Plotting"})," phase done individually by each farmer"]}),"\n",(0,t.jsxs)(i.li,{children:["a probabilistic audit phase, known as ",(0,t.jsx)(i.strong,{children:"Farming"}),", based on a recurring slot challenge from a secure randomness beacon, with a frequency of one challenge per second."]}),"\n"]}),"\n",(0,t.jsxs)("div",{align:"center",children:[(0,t.jsx)("img",{src:"/img/Consensus_Phases-light.svg#gh-light-mode-only",alt:"ConsensusPhases"}),(0,t.jsx)("img",{src:"/img/Consensus_Phases-dark.svg#gh-dark-mode-only",alt:"ConsensusPhases"})]}),"\n",(0,t.jsxs)(i.p,{children:["Since the blockchain history is not unique, farmers cannot simply store the raw blockchain history, otherwise dishonest\nfarmers could share a single copy of the blockchain history to emulate unlimited amount of disk space. Thus, one\nchallenge is how to make the ",(0,t.jsx)(i.em,{children:"plot"})," each farmer stores unique. This is done as part of the plotting phase explained\nbelow."]}),"\n",(0,t.jsxs)(i.p,{children:['Before the plotting phase, farmers need to "prepare" the raw blockchain history for compatibility with the Subspace\nplotting protocol. This is done in the archiving phase. Archiving is a deterministic process performed by all nonde. It is done\nongoingly, as the blockchain progresses and more blocks are produced. When archiving, farmers apply a technique called\nerror-correction coding, specifically the Reed--Solomon code. This is used to guarantee that even if some piece of data\n(a collection of blocks) is not stored by any of the farmers (hence not stored on the entire network), it could be\nrecovered by other pieces. The replication factor used is 1/2, which means that half of the storage on the network is\nused is dedicated specifically for this error-correction technique. However, for recovery purposes, it is much better\nthan using this space to store each block twice. Besides of applying the Reed-Solomon code, the archiving phase also\ninvolves a cryptographic primitive called commitment scheme (in Subspace we use a specific type called polynomial\ncommitments) in order to make the farming phase, where a farmer proves that she stored some piece of history, easier\nboth for the proving farmer and for the verifiers. More technical details can be found in the ',(0,t.jsxs)(i.a,{href:"/docs/consensus/consensus/archiving",children:[(0,t.jsx)(i.strong,{children:"Archiving"})," page"]}),"."]}),"\n",(0,t.jsx)(i.p,{children:"Next is the plotting phase, where the farmer creates her own unique plot. Plotting is divided into two steps. First, the farmer picks pieces of the blockchain history that she\nwill store on her disk. This is done by a deterministic algorithm, involving the farmer ID and the current blockchain height\namong others, such that pieces are allocated uniformly at random, and therefore guarantees with high probability that no\npiece of history will be missing."}),"\n",(0,t.jsx)(i.p,{children:'In the second part, the farmer "masks" her assigned pieces by a unique and verifiable "masking data". This is done in\norder to guarantee that each plot contains unique pieces of information, and so dishonest farmers cannot share the same\nraw history when participating in the protocol. The masking algorithm is deterministic as well, and involves the farmer\nID and piece of history, such that different farmers will obtain different masking data for the same piece. When winning a block (that is, when a farmer\nclaims to have a proof-of-space that gives them the eligibility to produce a block), the farmer has to show both the raw\npiece of history and the masking data for that piece. Since the masking data is verifiable, anyone can check that\nindeed this was the masking data for that specific piece of history and farmer ID.'}),"\n",(0,t.jsxs)(i.p,{children:["In practice, masking in Subspace is done by producing a string of bits that are XOR-ed with the bit representation of\nthe selected piece of history. It is crucial that the masking bits are produced in a process that takes a long time and\nis expensive, otherwise dishonest farmers can attempt to produce the masking data on the fly and re-use their raw data\nfor several plots. In Subspace, we chose to adopt the cryptographic data that is used in the ",(0,t.jsx)(i.a,{href:"https://www.chia.net/",children:"Chia protocol"}),",\nwhich demands both time and electricity for generation."]}),"\n",(0,t.jsx)(i.p,{children:"Once a farmer created her plot, she can start farming it. This phase is similar to other blockchains where some\nchallenge is drawn and the farmer checks if her resource -- the stored blockchain history in her plot -- gives her\neligibility to produce a block. As mentioned above, when winning a challenge and producing a block, as part of the\nproof the farmer has to present both the raw blockchain data as well as the masking data."}),"\n",(0,t.jsx)(i.p,{children:"The block challenges are drawn from a secure randomness beacon, which is updated every second. The randomness is obtained from a Proof-of-Time component, which is anchored in the blockchain history itself."}),"\n",(0,t.jsx)(i.p,{children:"Archiving, Plotting and Farming protocol are explained in more detail in the following section, and Proof-of-Time in the next one."})]})}function d(e={}){const{wrapper:i}={...(0,s.M)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},2172:(e,i,n)=>{n.d(i,{I:()=>a,M:()=>r});var t=n(1504);const s={},o=t.createContext(s);function r(e){const i=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(o.Provider,{value:i},e.children)}}}]);