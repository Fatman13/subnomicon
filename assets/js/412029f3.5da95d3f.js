"use strict";(self.webpackChunkportal=self.webpackChunkportal||[]).push([[186],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var c=n.createContext({}),l=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=l(a),h=o,u=d["".concat(c,".").concat(h)]||d[h]||m[h]||r;return a?n.createElement(u,s(s({ref:t},p),{},{components:a})):n.createElement(u,s({ref:t},p))}));function h(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,s=new Array(r);s[0]=d;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var l=2;l<r;l++)s[l]=a[l];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},5863:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var n=a(7462),o=(a(7294),a(3905));const r={title:"Plotting",sidebar_position:3,description:"Plotting Phase",keywords:["Consensus","Plotting"]},s=void 0,i={unversionedId:"consensus/consensus/plotting",id:"consensus/consensus/plotting",title:"Plotting",description:"Plotting Phase",source:"@site/docs/consensus/consensus/plotting.md",sourceDirName:"consensus/consensus",slug:"/consensus/consensus/plotting",permalink:"/docs/consensus/consensus/plotting",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Plotting",sidebar_position:3,description:"Plotting Phase",keywords:["Consensus","Plotting"]},sidebar:"tutorialSidebar",previous:{title:"Archiving",permalink:"/docs/consensus/consensus/archiving"},next:{title:"Farming",permalink:"/docs/consensus/consensus/farming"}},c={},l=[{value:"Proof-of-Space Encoding",id:"proof-of-space-encoding",level:2},{value:"Workflow",id:"workflow",level:2}],p={toc:l};function m(e){let{components:t,...r}=e;return(0,o.kt)("wrapper",(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Plotting is the process of creating and maintaining plots on a disk.\nThe Plotting protocol used in ",(0,o.kt)("em",{parentName:"p"},"Dilithium")," is based on two core ideas: erasure coding and memory-bandwidth-bound encoding. Erasure coding helps to protect the data against loss in the event of any failures and network partitions. Memory-bandwidth-bound encoding is a more ecological and economical alternative to proofs-of-work while providing provable time/memory trade-offs and security guarantees. Combining these two ideas allows us to create unique and provable replicas for each farmer that are difficult to fake with computation or to compress. This scheme also makes auditing and verifying the plots easier, ensuring the history data is recoverable."),(0,o.kt)("p",null,"During this phase, the pieces are gathered and organized into a plot of several sectors. Each sector contains an encoded replica of a uniformly random sample of pieces across all archived history. This sampling ensures that the data is distributed among the farmers proportionally to their pledged disk space and replicated evenly."),(0,o.kt)("h2",{id:"proof-of-space-encoding"},"Proof-of-Space Encoding"),(0,o.kt)("p",null,"The memory-bandwidth encoding construction comes from the paper ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"https://www.semanticscholar.org/paper/Beyond-Hellman's-Time-Memory-Trade-Offs-with-to-of-Abusalah-Alwen/39e70d67eeb5ce140171f6d0629daec3b54d74f3"},"Beyond Hellman's Time-Memory Trade-Offs with Applications to Proofs of Space"))," which predates the ",(0,o.kt)("a",{parentName:"p",href:"https://www.chia.net/"},"Chia")," protocol. We adopt a custom implementation of the Chia Proof-of-Space plotting function as a memory-bandwidth-bound function to encode, or \u201cmask,\u201d the pieces in the farmer plot."),(0,o.kt)("p",null,"In short, the PoS plotter generates a table of permuted outputs from a set of random functions. The size of the table is determined by a memory bandwidth requirement parameter, ",(0,o.kt)("em",{parentName:"p"},"k"),", and the random functions are determined by a ",(0,o.kt)("em",{parentName:"p"},"seed"),". When challenged at an ",(0,o.kt)("em",{parentName:"p"},"index"),", the table outputs a short ",(0,o.kt)("em",{parentName:"p"},"proof-of-space")," that can be efficiently verified.\nWe do not use the Proof-of-Space directly to verify that a farmer has pledged a certain amount of space, as Chia does. Instead, we use it to prove that a farmer utilized the required memory bandwidth for encoding the plot."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"PoSTable",src:a(5476).Z,width:"668",height:"428"})),(0,o.kt)("h2",{id:"workflow"},"Workflow"),(0,o.kt)("p",null,"A plot can cover the entire disk or span across multiple disks, and there is no limit to the amount of storage a farmer can pledge to the network. Plots consist of equally-sized sectors, currently around 1 GiB each. Each sector is a pseudorandom selection of 1,000 pieces, uniformly sampled throughout history up to that point. For example, if the farmer creates a new sector when the history consists of 50,000 pieces (50 GiB), the 1,000 pieces for this sector will be a uniform selection from the existing 50,000 pieces."),(0,o.kt)("p",null,"In addition, the farmer must save the current history size, as it will determine the point in the future when the sector will need to be updated with newer pieces. "),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"RawSector",src:a(321).Z,width:"1367",height:"480"})),(0,o.kt)("p",null,"Once the farmer has obtained all 1,300 pieces for this sector from the network, they can create an encoded replica. Only the piece\u2019s historical data, the record part, is encoded. The commitment and witness included in a piece are saved separately in the sector metadata, as they will be needed later for farming."),(0,o.kt)("p",null,"Each record is encoded separately and sequentially. For each record, the Plotting algorithm performs the following steps:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Derive a unique pseudorandom and verifiable ",(0,o.kt)("em",{parentName:"li"},"seed"),"."),(0,o.kt)("li",{parentName:"ol"},"Based on this ",(0,o.kt)("em",{parentName:"li"},"seed"),", generate a proof-of-space table using memory bandwidth resources set by the global protocol memory requirement parameter ",(0,o.kt)("em",{parentName:"li"},"k"),". 1. This memory-intensive computation prevents malicious farmers from creating replicas after the new block challenge is announced, making it more rational for them to store the replica rather than try to compute it on the fly every time."),(0,o.kt)("li",{parentName:"ol"},"Given the PoS table for this record, the farmer must:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Derive a starting index for lookup, which will also serve as the starting index for the extended (or erasure-coded) record."),(0,o.kt)("li",{parentName:"ul"},"Query the table for enough (",(0,o.kt)("span",{parentName:"li",className:"math math-inline"},(0,o.kt)("span",{parentName:"span",className:"katex"},(0,o.kt)("span",{parentName:"span",className:"katex-mathml"},(0,o.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,o.kt)("semantics",{parentName:"math"},(0,o.kt)("mrow",{parentName:"semantics"},(0,o.kt)("msup",{parentName:"mrow"},(0,o.kt)("mn",{parentName:"msup"},"2"),(0,o.kt)("mn",{parentName:"msup"},"15"))),(0,o.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"2^{15}")))),(0,o.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,o.kt)("span",{parentName:"span",className:"base"},(0,o.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8141em"}}),(0,o.kt)("span",{parentName:"span",className:"mord"},(0,o.kt)("span",{parentName:"span",className:"mord"},"2"),(0,o.kt)("span",{parentName:"span",className:"msupsub"},(0,o.kt)("span",{parentName:"span",className:"vlist-t"},(0,o.kt)("span",{parentName:"span",className:"vlist-r"},(0,o.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,o.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,o.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,o.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,o.kt)("span",{parentName:"span",className:"mord mtight"},(0,o.kt)("span",{parentName:"span",className:"mord mtight"},"15"))))))))))))),") proof-of-space values to mask every chunk of the record.")))),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"PoSLookup",src:a(2953).Z,width:"936",height:"780"})),(0,o.kt)("p",null,"Challenging the PoS table for proofs"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Erasure code (extend) the record data by interpolating a polynomial over chunks of the record and evaluating it over the lookup indices for the PoS table from the previous step."),(0,o.kt)("li",{parentName:"ol"},"Encode each extended record chunk by XOR-masking it with the corresponding proof-of-space value.")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"PieceEncoding",src:a(8538).Z,width:"984",height:"960"})),(0,o.kt)("p",null,"After all records in the sector have been encoded as described, the farmer spreads them into s-buckets chunk-wise. Ultimately, each bucket will contain chunks from all records. The first bucket will have the first chunks of each record, the second bucket will have the second chunks, and so on. The s-buckets are then written to disk, and the plotting process is complete."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"EncodedSector",src:a(8118).Z,width:"1346",height:"598"})),(0,o.kt)("p",null,"Each bucket represents a potential winning ticket in the block proposer lottery. For each challenge, a farmer will scan one s-bucket containing one chunk of each record they store in a sector and see whether any of them are eligible to win a block."),(0,o.kt)("p",null,"As a result, a farmer has a unique encoded replica that is difficult to compress or compute on demand. An economically rational farmer is incentivized to store as many honestly encoded replicas as possible to maximize their chances of winning a block."))}m.isMDXComponent=!0},8118:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/Encoded_Sector-32bec8d96779b083f323f7d1ba9993fb.png"},8538:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/Piece_Encoding-cd67705294657ed8c94953c7a4f5f3ed.png"},2953:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/PoS_Lookup-32481486292ce4cd2cc30ea81b3d1f44.png"},5476:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/PoS_Table-a6667cb0d74591a7fc32f9f5d09d14b3.png"},321:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/Raw_Sector-7a52a40dc742e0a717731fdcf99f00da.png"}}]);